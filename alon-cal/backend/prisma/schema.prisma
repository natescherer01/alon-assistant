generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/// User account model with soft delete support
/// Stores core user information and authentication credentials
model User {
  id                  String               @id @default(uuid()) @db.Uuid
  email               String               @unique @db.VarChar(255)
  passwordHash        String               @map("password_hash") @db.VarChar(255)
  firstName           String?              @map("first_name") @db.VarChar(100)
  lastName            String?              @map("last_name") @db.VarChar(100)
  createdAt           DateTime             @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt           DateTime             @updatedAt @map("updated_at") @db.Timestamptz(3)
  deletedAt           DateTime?            @map("deleted_at") @db.Timestamptz(3)
  timezone            String               @default("UTC") @db.VarChar(100)
  sleepStartTime      String?              @map("sleep_start_time") @db.VarChar(5)
  sleepEndTime        String?              @map("sleep_end_time") @db.VarChar(5)
  auditLogs           AuditLog[]
  calendarConnections CalendarConnection[]
  oauthStates         OAuthState[]
  sessions            Session[]

  @@index([email])
  @@index([deletedAt])
  @@map("users")
}

/// Active session tracking for JWT-based authentication
/// Each session represents an active login with device/location context
model Session {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String   @map("user_id") @db.Uuid
  tokenHash String   @map("token_hash") @db.VarChar(255)
  expiresAt DateTime @map("expires_at") @db.Timestamptz(3)
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(3)
  userAgent String?  @map("user_agent")
  ipAddress String?  @map("ip_address") @db.VarChar(45)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@index([tokenHash])
  @@map("sessions")
}

/// OAuth state tokens for CSRF protection during OAuth flow
/// Expires after 15 minutes for security
/// Cleaned up automatically after successful OAuth callback
model OAuthState {
  id        String           @id @default(uuid()) @db.Uuid
  userId    String           @map("user_id") @db.Uuid
  provider  CalendarProvider
  state     String           @unique @db.VarChar(255)
  expiresAt DateTime         @map("expires_at") @db.Timestamptz(3)
  createdAt DateTime         @default(now()) @map("created_at") @db.Timestamptz(3)
  consumed  Boolean          @default(false)
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([state])
  @@index([expiresAt])
  @@index([userId, provider])
  @@map("oauth_states")
}

/// Calendar connection model for OAuth-based and ICS calendar integrations
/// Stores encrypted access/refresh tokens for OAuth providers (Google, Microsoft, Apple)
/// Stores encrypted ICS subscription URLs for ICS calendars
/// Supports sync state tracking for all provider types
model CalendarConnection {
  id                   String                @id @default(uuid()) @db.Uuid
  userId               String                @map("user_id") @db.Uuid
  provider             CalendarProvider
  calendarId           String                @map("calendar_id") @db.VarChar(255)
  calendarName         String                @map("calendar_name") @db.VarChar(255)
  accessToken          String?               @map("access_token")
  refreshToken         String?               @map("refresh_token")
  tokenExpiresAt       DateTime?             @map("token_expires_at") @db.Timestamptz(3)
  calendarColor        String?               @map("calendar_color") @db.VarChar(7)
  isPrimary            Boolean               @default(false) @map("is_primary")
  isConnected          Boolean               @default(true) @map("is_connected")
  lastSyncedAt         DateTime?             @map("last_synced_at") @db.Timestamptz(3)
  createdAt            DateTime              @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt            DateTime              @updatedAt @map("updated_at") @db.Timestamptz(3)
  deletedAt            DateTime?             @map("deleted_at") @db.Timestamptz(3)
  syncToken            String?               @map("sync_token")
  delegateEmail        String?               @map("delegate_email") @db.VarChar(255)
  icsETag              String?               @map("ics_etag") @db.VarChar(255)
  icsLastModified      String?               @map("ics_last_modified") @db.VarChar(255)
  icsUrl               String?               @map("ics_url")
  isReadOnly           Boolean               @default(false) @map("is_read_only")
  user                 User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  events               CalendarEvent[]
  webhookSubscriptions WebhookSubscription[]

  @@unique([userId, provider, calendarId], name: "unique_user_calendar")
  @@index([userId])
  @@index([provider])
  @@index([isConnected])
  @@index([lastSyncedAt])
  @@index([deletedAt])
  @@index([delegateEmail])
  @@map("calendar_connections")
}

/// Webhook subscription model for tracking Microsoft Graph and Google Calendar webhooks
/// Manages webhook lifecycle including expiration and renewal
model WebhookSubscription {
  id                   String             @id @default(uuid()) @db.Uuid
  calendarConnectionId String             @map("calendar_connection_id") @db.Uuid
  provider             CalendarProvider
  subscriptionId       String             @map("subscription_id") @db.VarChar(255)
  resourcePath         String             @map("resource_path") @db.VarChar(500)
  expirationDateTime   DateTime           @map("expiration_datetime") @db.Timestamptz(3)
  clientState          String?            @map("client_state") @db.VarChar(255)
  notificationUrl      String             @map("notification_url")
  lastNotificationAt   DateTime?          @map("last_notification_at") @db.Timestamptz(3)
  isActive             Boolean            @default(true) @map("is_active")
  createdAt            DateTime           @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt            DateTime           @updatedAt @map("updated_at") @db.Timestamptz(3)
  calendarConnection   CalendarConnection @relation(fields: [calendarConnectionId], references: [id], onDelete: Cascade)

  @@unique([subscriptionId, provider], name: "unique_provider_subscription")
  @@index([calendarConnectionId])
  @@index([subscriptionId])
  @@index([expirationDateTime])
  @@index([isActive])
  @@index([provider])
  @@map("webhook_subscriptions")
}

/// Calendar event model for storing synced events from all providers
/// Stores events in a unified schema with support for complex recurrence patterns
/// Supports recurring events, attendees, and reminders as separate models
model CalendarEvent {
  id                    String               @id @default(uuid()) @db.Uuid
  calendarConnectionId  String               @map("calendar_connection_id") @db.Uuid
  providerEventId       String               @map("provider_event_id") @db.VarChar(255)
  title                 String               @db.VarChar(500)
  description           String?
  location              String?              @db.VarChar(500)
  startTime             DateTime             @map("start_time") @db.Timestamptz(3)
  endTime               DateTime             @map("end_time") @db.Timestamptz(3)
  isAllDay              Boolean              @default(false) @map("is_all_day")
  timezone              String               @default("UTC") @db.VarChar(100)
  status                EventStatus          @default(CONFIRMED)
  syncStatus            SyncStatus           @default(SYNCED) @map("sync_status")
  isRecurring           Boolean              @default(false) @map("is_recurring")
  recurrenceRule        String?              @map("recurrence_rule")
  recurrenceFrequency   RecurrenceFrequency? @map("recurrence_frequency")
  recurrenceInterval    Int?                 @map("recurrence_interval")
  recurrenceEndDate     DateTime?            @map("recurrence_end_date") @db.Timestamptz(3)
  recurrenceCount       Int?                 @map("recurrence_count")
  parentEventId         String?              @map("parent_event_id") @db.Uuid
  attendees             Json?
  reminders             Json?
  providerMetadata      Json?                @map("provider_metadata")
  htmlLink              String?              @map("html_link")
  lastSyncedAt          DateTime?            @map("last_synced_at") @db.Timestamptz(3)
  createdAt             DateTime             @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt             DateTime             @updatedAt @map("updated_at") @db.Timestamptz(3)
  deletedAt             DateTime?            @map("deleted_at") @db.Timestamptz(3)
  importance            EventImportance?     @default(NORMAL)
  outlookCategories     String?              @map("outlook_categories")
  conversationId        String?              @map("conversation_id") @db.VarChar(255)
  seriesMasterId        String?              @map("series_master_id") @db.VarChar(255)
  teamsEnabled          Boolean              @default(false) @map("teams_enabled")
  teamsMeetingUrl       String?              @map("teams_meeting_url")
  teamsConferenceId     String?              @map("teams_conference_id") @db.VarChar(255)
  teamsDialInUrl        String?              @map("teams_dial_in_url")
  recurrenceEndType     RecurrenceEndType?   @map("recurrence_end_type")
  recurrenceByDay       String?              @map("recurrence_by_day") @db.VarChar(100)
  monthDayType          MonthDayType?        @map("month_day_type")
  recurrenceByMonthDay  Int?                 @map("recurrence_by_month_day")
  recurrenceBySetPos    Int?                 @map("recurrence_by_set_pos")
  recurrenceByDayOfWeek DayOfWeek?           @map("recurrence_by_day_of_week")
  recurrenceByMonth     String?              @map("recurrence_by_month") @db.VarChar(50)
  exceptionDates        String?              @map("exception_dates")
  calendarConnection    CalendarConnection   @relation(fields: [calendarConnectionId], references: [id], onDelete: Cascade)
  parentEvent           CalendarEvent?       @relation("RecurringEventInstances", fields: [parentEventId], references: [id], onDelete: Cascade)
  childEvents           CalendarEvent[]      @relation("RecurringEventInstances")
  eventAttendees        EventAttendee[]
  eventReminders        EventReminder[]

  @@unique([calendarConnectionId, providerEventId], name: "unique_calendar_provider_event")
  @@index([calendarConnectionId])
  @@index([providerEventId])
  @@index([startTime])
  @@index([endTime])
  @@index([status])
  @@index([syncStatus])
  @@index([isRecurring])
  @@index([parentEventId])
  @@index([deletedAt])
  @@index([recurrenceFrequency])
  @@index([recurrenceEndDate])
  @@index([importance])
  @@index([conversationId])
  @@index([seriesMasterId])
  @@index([teamsEnabled])
  @@index([calendarConnectionId, startTime, endTime])
  @@index([calendarConnectionId, syncStatus])
  @@map("calendar_events")
}

/// Event attendee model for managing event participants
/// Supports RSVP tracking and organizer designation
model EventAttendee {
  id           String        @id @default(uuid()) @db.Uuid
  eventId      String        @map("event_id") @db.Uuid
  email        String        @db.VarChar(255)
  displayName  String?       @map("display_name") @db.VarChar(255)
  rsvpStatus   RsvpStatus    @default(NEEDS_ACTION) @map("rsvp_status")
  isOrganizer  Boolean       @default(false) @map("is_organizer")
  isOptional   Boolean       @default(false) @map("is_optional")
  comment      String?
  responseTime DateTime?     @map("response_time") @db.Timestamptz(3)
  createdAt    DateTime      @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt    DateTime      @updatedAt @map("updated_at") @db.Timestamptz(3)
  event        CalendarEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([eventId, email], name: "unique_event_attendee")
  @@index([eventId])
  @@index([email])
  @@index([rsvpStatus])
  @@index([isOrganizer])
  @@index([eventId, rsvpStatus])
  @@map("event_attendees")
}

/// Event reminder model for managing event notifications
/// Default: 30 minutes before event (Google Calendar default)
model EventReminder {
  id            String         @id @default(uuid()) @db.Uuid
  eventId       String         @map("event_id") @db.Uuid
  method        ReminderMethod @default(POPUP)
  minutesBefore Int            @map("minutes_before")
  createdAt     DateTime       @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt     DateTime       @updatedAt @map("updated_at") @db.Timestamptz(3)
  event         CalendarEvent  @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@index([eventId])
  @@index([minutesBefore])
  @@index([eventId, minutesBefore])
  @@map("event_reminders")
}

/// Audit log for security, compliance, and debugging
/// Tracks all significant user actions and system events
model AuditLog {
  id           String      @id @default(uuid()) @db.Uuid
  userId       String?     @map("user_id") @db.Uuid
  action       String      @db.VarChar(100)
  resourceType String?     @map("resource_type") @db.VarChar(50)
  resourceId   String?     @map("resource_id") @db.Uuid
  status       AuditStatus
  errorMessage String?     @map("error_message")
  ipAddress    String?     @map("ip_address") @db.VarChar(45)
  userAgent    String?     @map("user_agent")
  metadata     Json?
  createdAt    DateTime    @default(now()) @map("created_at") @db.Timestamptz(3)
  user         User?       @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([action])
  @@index([createdAt])
  @@index([status])
  @@index([resourceType, resourceId])
  @@map("audit_logs")
}

/// Calendar provider types supported by the application
enum CalendarProvider {
  GOOGLE
  MICROSOFT
  APPLE
  ICS

  @@map("calendar_provider")
}

/// Audit log action status
enum AuditStatus {
  SUCCESS
  FAILURE

  @@map("audit_status")
}

/// Calendar event status
enum EventStatus {
  CONFIRMED
  TENTATIVE
  CANCELLED

  @@map("event_status")
}

/// Calendar event sync status
enum SyncStatus {
  PENDING
  SYNCED
  FAILED
  DELETED

  @@map("sync_status")
}

/// Recurrence frequency for calendar events
enum RecurrenceFrequency {
  DAILY
  WEEKLY
  MONTHLY
  YEARLY

  @@map("recurrence_frequency")
}

/// RSVP status for event attendees
enum RsvpStatus {
  NEEDS_ACTION
  ACCEPTED
  DECLINED
  TENTATIVE

  @@map("rsvp_status")
}

/// Reminder method (email, popup, sms)
enum ReminderMethod {
  EMAIL
  POPUP
  SMS

  @@map("reminder_method")
}

/// Day of week for recurrence rules
enum DayOfWeek {
  SUNDAY
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY

  @@map("day_of_week")
}

/// Recurrence end type
enum RecurrenceEndType {
  NEVER
  DATE
  COUNT

  @@map("recurrence_end_type")
}

/// Month day type for monthly recurrence (specific date or relative day)
enum MonthDayType {
  DAY_OF_MONTH
  RELATIVE_DAY

  @@map("month_day_type")
}

/// Event importance level for Outlook/Exchange
enum EventImportance {
  LOW
  NORMAL
  HIGH

  @@map("event_importance")
}
